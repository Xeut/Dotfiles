#!/usr/bin/env bash

# --- Konfiguration & Sicherheit ---
set -euo pipefail

# Farben für die Ausgabe
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' 

# Verzeichnisse definieren
SCRIPT_PATH="$(readlink -f "${BASH_SOURCE[0]}")"
SCRIPT_DIR="$(dirname "$SCRIPT_PATH")"
TARGET_DIR="$HOME"
BACKUP_DIR="$HOME/dotfiles_backup_$(date +%Y%m%d_%H%M%S)"

# Systemd Definitionen (User-Level)
SERVICE_NAME="dotfiles-sync"
SYSTEMD_USER_DIR="$HOME/.config/systemd/user"

# Liste der Dateien/Ordner, die ignoriert werden sollen
EXCLUDE_LIST=(".git" ".gitignore" "README.md" "$(basename "$0")" ".DS_Store")

# --- Funktionen ---

log_info()    { echo -e "${GREEN}[INFO]${NC} $1"; }
log_warn()    { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error()   { echo -e "${RED}[ERROR]${NC} $1" >&2; }

is_excluded() {
    local item="$1"
    for ex in "${EXCLUDE_LIST[@]}"; do
        [[ "$item" == "$ex" ]] && return 0
    done
    return 1
}

setup_links() {
    log_info "Verarbeite Symlinks..."
    cd "$SCRIPT_DIR"

    for source_path in .* *; do
        [[ "$source_path" == "." || "$source_path" == ".." ]] && continue
        is_excluded "$source_path" && continue
        [[ ! -e "$source_path" ]] && continue

        local target_path="$TARGET_DIR/$source_path"
        local abs_source_path="$SCRIPT_DIR/$source_path"

        if [[ -L "$target_path" && "$(readlink -f "$target_path")" == "$abs_source_path" ]]; then
            continue # Bereits korrekt verlinkt
        fi

        if [[ -e "$target_path" || -L "$target_path" ]]; then
            log_warn "Backup: $target_path existiert. Verschiebe nach $BACKUP_DIR"
            mkdir -p "$BACKUP_DIR"
            mv "$target_path" "$BACKUP_DIR/"
        fi

        log_info "Link erstellt: $source_path"
        ln -s "$abs_source_path" "$target_path"
    done
}

sync_git() {
    log_info "Prüfe Git-Status..."
    cd "$SCRIPT_DIR"

    if [ ! -d ".git" ]; then
        log_warn "Kein Git-Repo in $SCRIPT_DIR. Überspringe Push."
        return
    fi

    if [[ -n $(git status --porcelain) ]]; then
        log_info "Änderungen gefunden. Pushe zu GitHub..."
        git add .
        git commit -m "Auto-sync: $(date +'%Y-%m-%d %H:%M:%S')"
        git push origin main && log_info "Push erfolgreich." || log_error "Push fehlgeschlagen."
    else
        log_info "Alles aktuell."
    fi
}

manage_systemd() {
    local service_file="$SYSTEMD_USER_DIR/$SERVICE_NAME.service"
    local timer_file="$SYSTEMD_USER_DIR/$SERVICE_NAME.timer"

    if systemctl --user list-timers | grep -q "$SERVICE_NAME.timer"; then
        log_info "Systemd-Job ist bereits aktiv."
        return
    fi

    log_info "Erstelle Systemd-Job für automatische Synchronisierung (10min)..."
    mkdir -p "$SYSTEMD_USER_DIR"

    # Service File erstellen
    cat <<EOF > "$service_file"
[Unit]
Description=Dotfiles Auto-Sync Service

[Service]
Type=oneshot
ExecStart=$SCRIPT_PATH
EOF

    # Timer File erstellen
    cat <<EOF > "$timer_file"
[Unit]
Description=Dotfiles Auto-Sync Timer

[Timer]
OnBootSec=2min
OnUnitActiveSec=10min
Unit=$SERVICE_NAME.service

[Install]
WantedBy=timers.target
EOF

    # Systemd neu laden und Timer starten
    systemctl --user daemon-reload
    systemctl --user enable --now "$SERVICE_NAME.timer"
    log_info "Systemd-Job erfolgreich installiert und gestartet!"
}

# --- Ausführung ---

main() {
    # Nur interaktiv fragen
    if [[ -t 0 ]]; then
        echo "Dieses Skript richtet Symlinks ein, erstellt einen 10-Minuten-Job und pusht zu Git."
        read -p "Fortfahren? (j/n) " -n 1 -r
        echo
        [[ ! $REPLY =~ ^[Jj]$ ]] && { log_warn "Abgebrochen."; exit 0; }
    fi

    setup_links
    sync_git
    manage_systemd # Stellt sicher, dass der Job läuft
    
    log_info "Vorgang abgeschlossen."
}

main "$@"
